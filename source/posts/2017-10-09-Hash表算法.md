---
title: 哈希表
tags:
  - Hash
  - 数据结构
category: 数据结构
abbrlink: 850f2080
date: 2017-10-09 20:39:53
---
## 前言

数组和链表的比较:

1. 数组内的元素在内存中是连续存放的；链表的元素不是连续的，而是通过指针联系在一起．
2. 数组的长度必须固定；链表可以动态分配存储空间
3. 数组从栈中分配；链表从堆分配空间

<!-- more -->

在查询和插入删除上的区别：

1. 查询．数组可以通过索引找到元素，而链表需要从头遍历．所以数组查询效率高于链表
`note`从头遍历时间复杂度为O(n),采用二叉排序树存储，时间复杂度O(logn)
2. 插入或删除．数组插入和删除需要移动大量的元素，而链表只需要改变指针指向．所以插入删除链表效率高于数组

而哈希表介于两者之间:既具备数组的高效查询，又能融合链表增加和删除元素的优势

## 实现
哈希表就是根据Key直接访问访问对应的值的存储结构．对于不同长度的输入产生一个固定长度输出，散列结果应具有同一性(输出应尽量分布均匀)和雪崩效应(微笑的输入变化导致输出发生巨大的变化)

实现思路：｀
将key通过散列函数转换成数组的索引．如果没有内存限制，那么可以将健作为索引，需要定义m>n,即数组的长度大于元素的数量，时间复杂度为O(1)．由于将近乎无限的关键字集合压缩映射到有限的哈希表中的地址值中，那么必然存在产生＂冲突＂的现象，需要处理哈希碰撞冲突．
关于哈希表实现的两个关键在于哈希函数的构造和冲突的解决方法．

## 常见的散列函数构造方法

1. **直接寻址法**
取某个关键字的线性函数值为散列地址，比例在0~100的年龄统计表里，可以直接将年龄作为地址,即
    $$f(key) = a * key + b$$
2. **平方取中法**
假设关键字是123,那么平方是1522756，取中间3位就是227，作为散列地址．`适用于关键字位数少`
3. **折叠法**
将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。叠加方法又分为移位叠加和边界叠加．`适用于关键字位数较多`
4. **减去法**
减去一个特定数值求得存储地址．
5. **基数转化法**
将十进制X看作其他进制，例如十三进制，再转换成十进制取其中几位作为存储地址．
6. **取模余数法**
对于散列表长度为m的散列公式函数为:$f(key) = key mod p(p<=m)$
这种方法的关键在于p的选取，根据经验:模p取不大于表长且最接近表长m素数时效果最好，且p最好取1.1n～1.7n之间的一个素数（n为存在的数据元素个数）
7. **随机数法**
取关键字的随机函数值作为散列地址，即$f(key) = random(key)$.`适用于长度不确定`

实际应用中需要根据关键字位数，分布情况，散列表长度等因素选择合适的策略，可以采用多种方式协作处理．

## 处理冲突
1. **链地址法**
解决冲突的一种常用方法，将所有散列到同一个地址元素保存在一个同义词链表里，散列数组中只保存链表的头指针。
`实例`
假设有哈希表长度m = 5, f(key) = key mod 5, 关键词序列为3, 12, 7, 19, 24, 32, 26，那么采用外链地址法会建立如下哈希表：

链地址法处理简单，没有堆积现象，因此平均查找长度较小。另外结点空间是动态申请的，适合于表长未知的情况

2. **开放定址法**
开放定址，即在散列产生冲突的时候，寻找下一个散列地址，只要表的空间足够大，那么总能找到位置插入元素。分为一下几种方法：

- 线性探测法
线性探测的函数为 $f(k, i) = (h(k) + 1) mod m, i = 0, 1, 2,.., m - 1$
步骤：
首先探查 h(k) mod m的位置，当被占用时，继续探查(h(k) + 1) mod m的位置，如果依然被占用，那么继续探查，直到找到合适的位置，或者达到表的末尾，则停止。

- 二次探测法
二次探测在一次探测的基础上增加了一个二项式， $f(k, i) = (h(k) + c_1i + c_2i^2) mod m$,相对线性探测，二次探测群聚现象没那么重，但依然存在二次群聚。

- 双散列函数探测法



3. **建立公共溢出区**
单独设立一个溢出表，只要散列值发生冲突，就存入改表中。

