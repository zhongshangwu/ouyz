---
title: 并发编程简介
tags:
  - Python
  - 并发
categories: Python
abbrlink: 7a7167a
date: 2017-11-23 13:34:26
---

## 前言

并发是计算机编程的一个重要概念，指多个子任务同时运行，从而提高整个任务的性能。
在继续学习Python并发编程之前，先介绍并发编程的概念。
<!-- more -->
## 并发编程解决的问题

## 进程和线程

`进程`(也叫重量级进程)，指一个执行中程序。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。进程也可以通过 `fork` 和 `spawn` 操作 来完成其它的任务。不过各个进程有自己的内存空间，数据栈等，所以只能使用进程间通讯(IPC)， 而不能直接共享信息。

`线程`(也称为轻量级进程)，跟进程类似，不过它们运行在同一个进程中，共享相同的上下文。它们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。

线程有开始，顺序执行和结束三部分。它有一个自己的指令指针，记录当前的运行上下文。 线程的运行可能被抢占(中断)，或暂时的被挂起(也叫睡眠)---这种做法称为让步(yielding)。 

一个进程中的各个线程之间共享同一片数据空间，所以线程之间可以比进程之间更方便地共享数据以及相互通讯。但是这种分享也会带来一个新的问题：竞态条件。
>我们知道，线程，在计算机里面通常的分类是内核级线程和用户级线程。内核级线程的调度是由系统完成的，而用户级线程的调度是由用户来控制的。那么Python标准库提供的线程是那一类呢？如果我们了解或者使用过gevent和eventlet，进行下对比，我们就很容易回答出来了。Python提供的线程是内核级的，而gevent和eventlet提供的则是用户级的线程。这类用户级的线程，我们叫它协程，也可以叫green thread。本文中的线程，主要针对Python标准库提供的线程。下文提到的线程一词，也都是指Python标准库提供的线程。

## 什么是线程安全

当多个线程同时运行时，保证运行结果符合预期，就是线程安全的。

### 线程切换上下文

在单核处理中，CPU通过给每个线程分配时间片来支持多线程执行代码。在切换前会保存上一个任务的状态，以便下一次换回这个任务的时候，可以再加载这个任务的状态。所以从保存到再加载状态的过程称为上下文切换。

### 竞态条件和临界区

当某个计算的正确性取决于多个线程的交替执行时序时，那么就会产生`竞态条件`，导致竞态条件发生的代码区称作`临界区`。

最为常见的竞态条件就是“先检查后执行”。例如，延迟初始化：
```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance


class Simple(Singleton):
    pass
```
假设两个线程同时实例化Simple类，A发现`cls._instance`为`None`，因而创建的Simple对象；B同样需要判断`cls._instance`是否为空，此时的`cls._instance`是否为空，取决于不可预测的时序，包括线程调度方式，以及A创建对象需要对象到设置`_instance`需要花费多久时间。如果B也检查为空，那么就会有两个不同的simple实例。

还有另外一种竞态条件类型：“读取－修改－写入”。例如，计数器(无法保证没其他线程更新使用count值)：
```python
>>> dis.dis('count += 1')
              0 LOAD_NAME                0 (count)  # 加载count变量的值
              3 LOAD_CONST               0 (1)
              6 INPLACE_ADD                         # 加1
              7 STORE_NAME               0 (count)  # 让count变量指向新的值
             10 LOAD_CONST               1 (None)
             13 RETURN_VALUE
```

## 如何解决线程安全问题

1. **无状态(Stateless)**
    由于线程访问无状态对象(没有域，也没有任何对其他类中域的引用)的行为不会影响到其他线程中操作的正确性，因此，无状态对象是线程安全的。

    例如，在Java中的Servlet设计成无状态的，这样在大量并发请求中，能够线程安全地处理请求。

2. **不可变性(Immuable)**
    涉及同步需求的另一个方法就是使用不可变对象，许多的线程安全问题都是由于不正当的多个线程同时访问同个对象的一个可变状态而引起的。如果对象的状态不可改变，那么问题与复杂性就随之消失了。

    例如，在Java里可以通过关键字`final`声明不可变变量，在Python里可以通过只读`特性`来达到相同的目的。不过两者需要确保在对象属性构造过程的

3. **原子性操作(CAS)**
    线程执行的过程中，有时需要保证一系列操作以原子的方式执行。

    例如，在Python中，由于GIL的存在以及最小执行单元是字节码，许多built-in的类型的读写操作本身都是原子操作的。但是有时候，Python中的一行代码是被解释成了多条字节码，也就是非原子操作的。这是需要通过同步机制来实现原子性。

4. **锁机制(Lock)**
    - `互斥锁(mutex)`是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。在多进程编程中，只防止多个进程同时对同一共享内存进行读写的机制。用来保护临界区的。

    - `自旋锁(spinlock)`自旋锁与互斥锁有点类似，是互斥锁的一种实现。自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是 否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁,适合于适合于保持时间较短的情况，这种锁可能存在两个问题：死锁和过多占用cpu资源(`忙等待`)。

        > **自旋锁导致死锁**
        想象你的内核代码请求到一个自旋锁并且在它的临界区里做它的事情。在中间某处，你的代码失去了处理器：它调用了一个函数（copy_from_user，假设）使进程进入睡眠；或者内核抢占发威，一个更高优先级的进程将你的代码推到了一边(注意,这都是假设,自旋锁其实不允许这些操作)。此时，正好某个别的进程或线程想获取同一个锁，如果这个线程运行在和你的内核代码不同的处理器上（幸运的情况），那么它可能要自旋等待一段时间（可能很长），当你的代码从休眠中唤醒或者重新得到处理器并释放锁，它就能得到锁。而最坏的情况是，那个想获取锁得线程刚好和你的代码运行在同一个处理器上，这时它将一直持有CPU进行自旋操作，导致你的代码永远不可能有任何机会来获得CPU释放这个锁了，这就是悲催的死锁。 

        自旋锁旋锁有个特性：`被自旋锁保护的临界区代码执行时，它不能因为任何原因放弃处理器`。
            1. 被自旋锁保护的临界区代码执行时不能进入休眠；
            2. 被自旋锁保护的临界区代码执行时是不能被被其他中断中断；
            3. 被自旋锁保护的临界区代码执行时，内核不能被抢占。

    - `可重入锁`指线程可以重复获得它已经持有的锁。例如threading模块的RLock。

    - `公平锁`指每个线程抢占锁的顺序为先后调用lock方法的顺序依次获取锁，类似于排队吃饭。而非公平锁指线程抢占锁的顺序随机的。

    - `乐观锁`一种并发控制的思想，相对于悲观锁需要获取锁，才能访问资源，乐观锁假设并发事务不会彼此相互影响，在数据提交的时候会检查，如果发生冲突，会返回错误信息，并由用户决定如何处理。可以通过版本号或者时间戳来实现。

    - `信号量(semaphore)`是一种更高级的同步机制，本质上是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减1；当线程完成一次对semaphore对象的释放（release）时，计数值加1。当计数值为0，则线程等待，该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态。适用于控制一个仅支持有限个用户的共享资源，互斥锁可以看做二值信号量。

5. **线程封闭(ThreadLocal)**
    当访问共享数据的时候，通常需要同步。而避免使用同步的一种方式就是不共享数据，如果仅在单线程中访问数据，就不需要同步。
    而`栈封闭`是一种更强的线程封闭技术，只能通过局部变量访问对象，数据保存在执行线程的栈中。
    更加规范的方法是使用`ThreadLocal`对象，例如threading.local，Flask中的LocalStack以及Werkebug实现的LocalStack和LocalProxy。


